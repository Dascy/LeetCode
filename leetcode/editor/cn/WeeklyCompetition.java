import java.util.*;import java.util.concurrent.atomic.AtomicInteger;/** * @author dongjunzhi * @Title: WeeklyCompetition * @ProjectName LeetCode * @Description: 周赛区 * @create 2024/7/7 10:22 */public class WeeklyCompetition {    public static void main(String[] args) {        winningPlayerCount(2, new int[][]{{0, 8}, {0, 3}});    }    public int minFlips(int[][] grid){        int m = grid.length;        int n = grid[0].length;        int ans =0;        for (int i = 0; i < m/2; i++) {            for (int j = 0; j < n/2; j++) {                int cnt = grid[i][j]+grid[i][n - j - 1]+ grid[m - i - 1][j]+ grid[m - i - 1][n - j - 1];                ans += Math.min(cnt,4-cnt);            }        }        if (m%2>0&&n%2>0){            ans += grid[m / 2][n / 2];        }        int diff=0,cnt=0;        if (m%2>0){            for (int j = 0; j < n / 2; j++) {                if (grid[m / 2][j] != grid[m / 2][n - 1 - j]) {                    diff += 1;                } else {                    cnt += grid[m / 2][j] * 2;                }            }        }        if (n%2>0){            for (int i = 0; i < m / 2; i++) {                if (grid[i][n / 2] != grid[m - 1 - i][n / 2]) {                    diff += 1;                } else {                    cnt += grid[i][n / 2] * 2;                }            }        }        return ans + (diff > 0 ? diff : cnt % 4);    }     public int minFlips1(int[][] grid) {        int m = grid.length;        int n = grid[0].length;        int t1 = 0;        for (int i = 0; i < m; i++) {            int[] row = grid[i];            int l = 0, r = row.length - 1;            while (l <= r) {                if (row[r] != row[l]) {                    t1++;                }                l++;                r--;            }        }        int t2 = 0;        for (int i = 0; i < n; i++) {            int t = 0, d = m - 1;            while (t <= d) {                if (grid[t][i] != grid[d][i]) {                    t2++;                }                t++;                d--;            }        }        return Math.min(t2, t1);    }    private boolean isPalindromic(int[] row) {        return true;    }    public static int winningPlayerCount(int n, int[][] pick) {        int num = 0;        int[][] cnt = new int[n][11];        for (int i = 0; i < pick.length; i++) {            int a = pick[i][0];            int color = pick[i][1];            cnt[a][color]++;        }        a:        for (int i = 0; i < n; i++) {            for (int j = 0; j < cnt[i].length; j++) {                if (cnt[i][j] > i) {                    num++;                    continue a;                }            }        }        return num;    }    public int nonSpecialCount(int l, int r) {        int cnt = 0;        for (int i = 2; i <= Math.sqrt(r); i++) {            if (i * i <= r && i * i >= l && isPrime(i)) {                cnt++;            }        }        return r - l + 1 - cnt;    }    public boolean isPrime(int n) {        for (int i = 2; i <= Math.sqrt(n); i++) {            if (n % i == 0) return false;        }        return true;    }    public boolean canAliceWin(int[] nums) {        int two = 0;        int one = 0;        for (int i = 0; i < nums.length; i++) {            if (nums[i] > 9) {                two += nums[i];            } else {                one += nums[i];            }        }        return one == two ? false : true;    }    public static int numberOfSubstrings(String s) {        char[] chars = s.toCharArray();        int zero = 0;        int one = 0;        int num = 0;        for (int i = 0; i < chars.length; i++) {            if (chars[i] == '0') {                zero++;            } else {                one++;            }        }        int t = zero, y = one;        for (int i = 0; i < chars.length; i++) {            if (chars[i] == '0') {                t--;            } else {                y--;            }            if (y >= t * t) {                num++;            }        }        t = zero;        y = one;        for (int i = chars.length - 1; i >= 0; i--) {            if (chars[i] == '0') {                t--;            } else {                y--;            }            if (y >= t * t) {                num++;            }        }        return num;    }    public int numberOfSubmatrices(char[][] grid) {        int n = grid.length;        int m = grid[0].length;        int ans = 0;        int[][][] sum = new int[n + 1][m + 1][2];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                sum[i + 1][j + 1][0] = sum[i + 1][j][0] + sum[i][j + 1][0] - sum[i][j][0];                sum[i + 1][j + 1][1] = sum[i + 1][j][1] + sum[i][j + 1][1] - sum[i][j][1];                if (grid[i][j] != '.') {                    sum[i + 1][j + 1][grid[i][j] & 1] += 1;                }                if (sum[i + 1][j + 1][0] > 0 && sum[i + 1][j + 1][0] == sum[i + 1][j + 1][1]) {                    ans++;                }            }        }        return ans;    }    public String getEncryptedString(String s, int k) {        int n = s.length();        char[] chars = new char[n + k];        for (int i = 0; i < n + k; i++) {            if (i >= n) {                chars[i] = s.charAt(i % n);            } else {                chars[i] = s.charAt(i);            }        }        char[] array = s.toCharArray();        for (int i = 0; i < array.length; i++) {            array[i] = chars[i + k];        }        return new String(array);    }}